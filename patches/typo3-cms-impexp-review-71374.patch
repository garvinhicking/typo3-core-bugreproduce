From f64b80a8728689f4d9aec5514b50763d986f3676 Mon Sep 17 00:00:00 2001
From: Nikita Hovratov <nikita.h@live.de>
Date: Wed, 29 Sep 2021 19:55:51 +0200
Subject: [PATCH] [BUGFIX] Enable Export/Import of page translations

The impexp system extension is now able to export translated pages. This
essential functionality has not been implemented up until now.

Also, specific language variants can be exported, that will only
contain records matching the requested language. This "hidden
feature" can be accessed by right-clicking on a page's icon in the
translation overview and selecting "export". This feature was
available before, but the export never included actual translated
records before.

In addition, the relation field "l10n_source" is taken care of while
exporting/importing. Normally this would happen automatically, if there
was a refindex entry for that. However, no references are saved for
the tables "pages" and "tt_content". This seems to be another bug and
should be fixed in another patch. After this, some code can be cleaned
up.

Functional tests have been added to verify the exported data.

Resolves: #93470
Resolves: #94616
Releases: main, 12.4
Change-Id: I6f8ab179c524b161dd7cf083cdc89b8cc05bf8b0
---

diff --git a/Classes/Export.php b/Classes/Export.php
index 192f1f1..87a76a1 100644
--- a/Classes/Export.php
+++ b/Classes/Export.php
@@ -17,6 +17,7 @@
 
 namespace TYPO3\CMS\Impexp;
 
+use Doctrine\DBAL\ArrayParameterType;
 use Doctrine\DBAL\Result;
 use TYPO3\CMS\Backend\Utility\BackendUtility;
 use TYPO3\CMS\Core\Core\Environment;
@@ -24,6 +25,7 @@
 use TYPO3\CMS\Core\Database\ConnectionPool;
 use TYPO3\CMS\Core\Database\Query\QueryHelper;
 use TYPO3\CMS\Core\Database\Query\Restriction\DeletedRestriction;
+use TYPO3\CMS\Core\Database\Query\Restriction\HiddenRestriction;
 use TYPO3\CMS\Core\Database\Query\Restriction\WorkspaceRestriction;
 use TYPO3\CMS\Core\Database\ReferenceIndex;
 use TYPO3\CMS\Core\Exception;
@@ -253,10 +255,33 @@
                 $this->removeExcludedPagesFromPageTree($pageTree);
                 $this->setPageTree($pageTree);
                 $this->flatInversePageTree($pageTree, $pageList);
+                $pagesFieldnameLanguage = ($GLOBALS['TCA']['pages']['ctrl']['languageField'] ?? 'sys_language_uid');
+                $pagesFieldnameLanguageParent = ($GLOBALS['TCA']['pages']['ctrl']['transOrigPointerField'] ?? 'l10n_parent');
+
                 foreach ($pageList as $pageUid => $_) {
                     $record = BackendUtility::getRecord('pages', $pageUid);
                     if (is_array($record)) {
                         $this->exportAddRecord('pages', $record);
+                        foreach ($this->getTranslationForPage((int)$record['uid'], $this->excludeDisabledRecords) as $pageTranslation) {
+                            // Export l10n translations
+                            // All exported records need to be considered within "insidePageTree", not "outsidePageTree",
+                            // because they actually ARE part of the page tree. To achieve this, their UID index is
+                            // added into $this->dat['header']['pagetree'].
+                            $this->exportAddRecord('pages', $pageTranslation);
+
+                            // Be sure to not overwrite existing parts of the pagetree
+                            // Integrate the extra record into the internal pagetree array
+                            $this->dat['header']['pagetree'][(int)$pageTranslation['uid']]['uid'] = (int)$pageTranslation['uid'];
+                        }
+
+                        // Translated pages can also be directly exported; in that case the pageList may
+                        // point to the UID of a translated page, and not the root page. Since tt_content
+                        // records are bound to the default page UID, those records would be missing.
+                        // So we use the page ID of the default language, and then attach all records
+                        // for that page ID, which also match the selected page's language.
+                        if (($record[$pagesFieldnameLanguageParent] ?? 0) > 0) {
+                            $this->addRecordsForPid((int)$record[$pagesFieldnameLanguageParent], $this->tables, [$record[$pagesFieldnameLanguage]]);
+                        }
                     }
                     $this->addRecordsForPid((int)$pageUid, $this->tables);
                 }
@@ -277,6 +302,59 @@
     }
 
     /**
+     * Add page translations to list of pages
+     *
+     * @param int $currentPage
+     * @param bool $considerHiddenPages
+     * @param int[] $limitToLanguageIds
+     * @return iterable<array>
+     */
+    public function getTranslationForPage(
+        int $currentPage,
+        bool $considerHiddenPages,
+        array $limitToLanguageIds = []
+    ): iterable {
+        $queryBuilder = GeneralUtility::makeInstance(ConnectionPool::class)->getQueryBuilderForTable('pages');
+        $queryBuilder->getRestrictions()
+            ->removeAll()
+            ->add(GeneralUtility::makeInstance(WorkspaceRestriction::class, 0))
+            ->add(GeneralUtility::makeInstance(DeletedRestriction::class));
+        if (!$considerHiddenPages) {
+            $queryBuilder->getRestrictions()->add(GeneralUtility::makeInstance(HiddenRestriction::class));
+        }
+        $constraints = [
+            $queryBuilder->expr()->eq(
+                ($GLOBALS['TCA']['pages']['ctrl']['transOrigPointerField'] ?? 'l10n_parent'),
+                $queryBuilder->createNamedParameter($currentPage, Connection::PARAM_INT)
+            ),
+        ];
+        if (!empty($limitToLanguageIds)) {
+            $constraints[] = $queryBuilder->expr()->in(
+                ($GLOBALS['TCA']['pages']['ctrl']['languageField'] ?? 'sys_language_uid'),
+                $queryBuilder->createNamedParameter($limitToLanguageIds, ArrayParameterType::INTEGER)
+            );
+        } else {
+            // Ensure consistency by only fetching pages where not only l10n_parent matches, but also a
+            // sys_language_uid > 0 exists.
+            $constraints[] = $queryBuilder->expr()->gt(
+                $GLOBALS['TCA']['pages']['ctrl']['languageField'] ?? 'sys_language_uid',
+                0
+            );
+        }
+
+        $result = $queryBuilder
+            ->select('*')
+            ->from('pages')
+            ->where(...$constraints)
+            ->orderBy('uid', 'ASC')
+            ->executeQuery();
+
+        while ($row = $result->fetchAssociative()) {
+            yield $row;
+        }
+    }
+
+    /**
      * Initialize all settings for the export
      */
     protected function initializeExport(): void
@@ -428,18 +506,25 @@
      *
      * @param int $pid Page id for which to select records to add
      * @param array $tables Array of table names to select from
+     * @param array $restrictToLanguageIds Array of sys_language_uid IDs to allow records for.
      */
-    protected function addRecordsForPid(int $pid, array $tables): void
+    protected function addRecordsForPid(int $pid, array $tables, array $restrictToLanguageIds = []): void
     {
+        $isRestrictToLanguageIds = $restrictToLanguageIds !== [];
         foreach ($GLOBALS['TCA'] as $table => $value) {
             if ($table !== 'pages'
                 && (in_array($table, $tables, true) || in_array('_ALL', $tables, true))
                 && $this->getBackendUser()->check('tables_select', $table)
                 && !($GLOBALS['TCA'][$table]['ctrl']['is_static'] ?? false)
             ) {
+                $languageField = $GLOBALS['TCA'][$table]['ctrl']['languageField'] ?? null;
                 $statement = $this->execListQueryPid($pid, $table);
                 while ($record = $statement->fetchAssociative()) {
                     if (is_array($record)) {
+                        // Skip the record, when languageId restrictions are enabled, and the record's language is not requested
+                        if ($isRestrictToLanguageIds && $languageField && isset($record[$languageField]) && !in_array($record[$languageField], $restrictToLanguageIds, true)) {
+                            continue;
+                        }
                         $this->exportAddRecord($table, $record);
                     }
                 }
@@ -533,6 +618,18 @@
                 $this->dat['records'][$table . ':' . $row['uid']] = [];
                 $this->dat['records'][$table . ':' . $row['uid']]['data'] = $row;
                 $this->dat['records'][$table . ':' . $row['uid']]['rels'] = $relations;
+                // There are no refindex entries for l10n_source of pages and tt_content, so we have to add them here manually for now.
+                // @todo can be removed, when this can come from ReferenceIndex.
+                if (($table === 'pages' || $table === 'tt_content')) {
+                    $fieldNameTranslationSource = ($GLOBALS['TCA'][$table]['ctrl']['translationSource'] ?? 'l10n_source');
+                    if (isset($row[$fieldNameTranslationSource]) && ((int)$row[$fieldNameTranslationSource]) > 0) {
+                        $this->dat['records'][$table . ':' . $row['uid']]['rels'][$fieldNameTranslationSource]['type'] = 'db';
+                        $this->dat['records'][$table . ':' . $row['uid']]['rels'][$fieldNameTranslationSource]['itemArray'][0] = [
+                            'id' => $row[$fieldNameTranslationSource],
+                            'table' => $table,
+                        ];
+                    }
+                }
                 // Add information about the relations in the record in the header:
                 $this->dat['header']['records'][$table][$row['uid']]['rels'] = $this->flatDbRelations($this->dat['records'][$table . ':' . $row['uid']]['rels']);
                 // Add information about the softrefs to header:
diff --git a/Classes/Import.php b/Classes/Import.php
index 109f244..a1eea9e 100644
--- a/Classes/Import.php
+++ b/Classes/Import.php
@@ -1051,6 +1051,10 @@
                         ) {
                             $importData[$table][$ID][$field] = $this->getReferenceDefaultValue($GLOBALS['TCA'][$table]['columns'][$field]['config']);
                         }
+                        // Set to "0" for integer fields, or else we will get a db error in DataHandler persistence.
+                        if ($field === ($GLOBALS['TCA'][$table]['ctrl']['translationSource'] ?? 'l10n_source')) {
+                            $importData[$table][$ID][$field] = 0;
+                        }
                         break;
                     case 'flex':
                         // Set blank now, fix later in setFlexFormRelations().
@@ -1194,7 +1198,7 @@
                         if (isset($relation['type']) && !($table === 'sys_file_reference' && $field === 'uid_local') && $relation['type'] === 'db' && isset($GLOBALS['TCA'][$table]['columns'][$field])) {
                             if (is_array($relation['itemArray'] ?? null) && !empty($relation['itemArray'])) {
                                 $fieldTca = $GLOBALS['TCA'][$table]['columns'][$field];
-                                $actualRelations = $this->remapRelationsOfField($relation['itemArray'], $fieldTca['config']);
+                                $actualRelations = $this->remapRelationsOfField($relation['itemArray'], $fieldTca['config'], $field);
                                 $updateData[$table][$actualUid][$field] = implode(',', $actualRelations);
                             }
                         }
@@ -1230,9 +1234,10 @@
      *
      * @param array $fieldRelations Relations with original record UIDs
      * @param array $fieldConfig TCA configuration of the record field the relations belong to
+     * @param string $field The TCA fieldname of the relation operated on
      * @return array Array of relation strings with actual record UIDs
      */
-    protected function remapRelationsOfField(array $fieldRelations, array $fieldConfig): array
+    protected function remapRelationsOfField(array $fieldRelations, array $fieldConfig, string $field = ''): array
     {
         $actualRelations = [];
 
@@ -1248,6 +1253,9 @@
                     } catch (\Exception $e) {
                         $actualRelations[] = 'file:' . $actualUid;
                     }
+                } elseif ($field === 'l10n_source') {
+                    // l10n_source is of type "passtrough" so the "_" syntax won't be replaced.
+                    $actualRelations[] = $actualUid;
                 } else {
                     $actualRelations[] = $relation['table'] . '_' . $actualUid;
                 }
